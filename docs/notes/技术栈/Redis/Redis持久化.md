## RDB

RDB 是 redis 的数据备份文件，也叫数据快照，就是把 redis 中的所有数据都记录在磁盘中。当 redis 出现故障重启后，从磁盘中读取这个文件恢复数据。
快照文件又叫 RDB 文件，默认存在运行目录。

```bash
# 持久化命令 需要等待返回ok 适合在需要主动停止redis的时候或者redis马上就要宕机的时候使用
save # redis主进程来执行RDB，会阻塞所有命令，因为redis是单进程单线程的

# 推荐使用
bgsave  # 开启子线程在后台执行保存

```

Redis默认是开启RDB的

配置文件配置调整:
```conf
#  60 秒内有 1000 个 key 出现修改我就执行 RDB
save 60 1000

#关闭rdb 不自动执行rdb
save ""
```

### bgsave命令

bgsave 命令是 fork 主进程得到子进程，子进程共享主进程的内存数据，完成 fork 后读取内存数据并写入 RDB 文件中

- fork 的过程是阻塞的，redis 主进程无法做其他事情，完成后就随便做什么操作了

fork 采用的是 copy-on-write 技术：

- 当主进程执行读操作时，访问共享内存；
- 当主进程执行写操作时，则会拷贝一份数据，执行写操作。
- fork 完成后子进程和主进程共享一个内存，这个内存会变成只读，可以保证这次数据不会发生变化，如果子进程在写入 RDB 的时候，主进程需要修改数据，那么他就会拷贝一份需要修改的内容在内存中，不会影响到共享内存

![image.png](https://image.oyyp.top/img/202412211521874.png)

💡 页表是虚拟内存和物理内存的一个映射关系，每个进程都有自己的虚拟内存，进程无法直接操作物理内存，但是有映射关系，修改这个虚拟内存的数据的时候，根据映射关系也就间接的修改了物理内存

### 缺点

1. RDB 执行间隔长，两次 RDB 之间会存在数据丢失的风险
   `通过配置文件设置 save 60 1000 可以控制 RDB 执行，这个命令等价于 60 秒内有 1000 个 key 出现修改我就执行 RDB，这个 60 和 1000 不好设置，太长会导致数据丢失，太短会造成 CPU 压力`
2. fork 子进程、压缩、写出 RDB 文件都比较耗时

## AOF

AOF也叫追加文件。Redis处理的每个命令都会保存在AOF文件中，所以AOF其实是一个redis命令日志文件

AOF默认关闭，需要修改配置文件

```conf
# 是否开启AOF
appendonly yes

# AOF文件名称
appendfilename "文件名称.aof"
```

AOF执行策略
配置文件声明 appendfsync
appendfsync 可以配置如下3个：
```conf
#表示每执行一次写命令，立即记录到AOF文件 能保证数据安全性最高，性能最差
# 这里执行其实是两步，主进程写入内存，然后在保存在AOF文件中才返回成功 要写入内存又要写入磁盘所以性能不好
appendfsync always

#写命令执行完先放入AOF缓冲区（内存），然后每隔1秒将缓冲区数据写到AOF文件，是默认方案
# 有1s间隔，在这1s的时候出现宕机，导致数据会丢失，丢失的数据也就是1s内的数据
appendfsync everysec

#写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘
appendfsync no
```

### 缺点

每次执行写命令都会写入aof文件中导致aof文件特别大，而且写入同一个key的时候，只有最后一个写入命令才有效，之前aof记录的无效，那么怎么优化呢？

```bash
# 通过这个命令重写aof文件
bgrewriteaof 
```

可以通过配置文件配置bgrewriteaof命令执行契机：
```
#AOF文件比上次文件增长超过多少百分比则触发重写
auto-aof-rewrite-percentage 100
#AOF文件体积最小多大以上才触发重写
auto-aof-rewrite-min-size 64mb
```

## RDB 和 AOF比较

RDB存的是数据，AOF存的是命令

![image.png](https://image.oyyp.top/img/202412211609838.png)

## RDB和AOF结合使用

同时开启rdb和aof持久化时，重启只会加载aof文件，不会加载rdb文件，aof优先级高于rdb

**开启两种持久化：**

（1）在这种情况下，当redis重启的时候会优先载入aof文件来恢复原始的数据，

因为在通常情况下aof文件保存的数据集要比rdb文件保存的数据集要完整（一秒一次）

（2）rdb数据不是实时的，同时使用两者时服务器重启也只会找aof文件，那要不要只使用aof呢？

作者建议不要，因为rdb更适合用于备份数据库（aof在不断变化不好备份），留着rdb作为一个万一的手段

**方式：**

（1）开启混合模式

aof-use-rdb-preamble no 是否开启混合方式

（2）aof+rdb混合方式

二者搭配流程：RDB做全量持久化，AOF做增量持久化，意思就是RDB先通过快照的方式，先将系统或数据集里面的全部内容保存下来，然后，过后的一段时间（没有触发RDB的fsync）,就属于变化的数据（写命令），这些写命令就存到aof文件里面，二者同时发挥作用。


**同时关闭rdb+aof**

（1）save ""：禁用rdb，在禁用模式下，仍然可以使用命令save，bgsave生成rdb文件

（2）appendonly no:禁用aof，也可以使用命令生成aof文件