## 操作缓存和数据库是有3个问题需要考虑

### 删除缓存还是更新缓存

#### 更新缓存

1. 每次更新数据库都更新缓存，无效写操作多，每次都去更新缓存会耗时而且会增加redis压力

2. 如果这个时候去更新数据，需要去遍历找到对应的值在去修改比较耗时。

#### 删除缓存（推荐）

1. 每次更新数据库时删除缓存，查询的时候在添加到缓存中

2. 使用的时候才更新缓存。使用的时候才从DB中加载，也可以采用异步的方式填充缓存，比如开启一个线程定时将DB的数据刷到缓存中。

### 如何保证缓存与数据库的操作同时失败和成功

1. 单体系统，把缓存和数据库放在一个事务中
2. 分布式系统，使用TCC分布式事务

### 先操作缓存还是先操作数据库

高并发情况下存在线程交叉执行，导致数据库缓存不一致情况

建议先更新数据库后删除缓存，因为这种情况出现问题概率较小，但是一样无法保证一定不出问题，只是这样出现问题的概率较小

#### 先更新数据库，再更新缓存

如果同时有两个写请求需要更新数据，每个写请求都先更新数据库再更新缓存，在并发场景可能会出现数据不一致的情况。

![image.png](https://image.oyyp.top/img/202411281635027.png)

1. 写请求1更新数据库，将 age 字段更新为18；
2. 写请求2更新数据库，将 age 字段更新为20；
3. 写请求2更新缓存，缓存 age 设置为20；
4. 写请求1更新缓存，缓存 age 设置为18；

​ 执行完预期结果是数据库 age 为20，缓存 age 为20，结果缓存 age为18，这就造成了缓存数据不是最新的，出现了[脏数据](https://so.csdn.net/so/search?q=%E8%84%8F%E6%95%B0%E6%8D%AE&spm=1001.2101.3001.7020)。


####  先删缓存，再更新数据库

![image.png](https://image.oyyp.top/img/202411281637962.png)

1. 写请求删除缓存数据；
2. 读请求查询缓存未击中，紧接着查询数据库，将返回的数据回写到缓存中；
3. 写请求更新数据库。

结果：缓存是18 数据库是20

- 读请求已经设置了缓存，导致之后的读请求会一直获取到缓存中的值，但是这个值是错误的，只能等待下一个写请求才能重新修改缓存的值，导致大多数读请求都读取到错误的值
- 先删除缓存，在更新数据库导致图片中的情况出现概率较高
- 由于更新数据库的时间相对较长, 更容易被其他线程抢占


#### 先更新数据库，再删除缓存（推荐）

在实际的系统中针对写请求还是推荐先更新数据库再删除缓存，但是在理论上还是存在问题。

![image.png](https://image.oyyp.top/img/202411281638631.png)

1. 读请求先查询缓存，缓存未击中（key过期），查询数据库返回数据；
2. 写请求更新数据库，删除缓存；
3. 读请求回写缓存；

- 极端情况下需要满足的条件稍微苛刻一点，需要保证刚好key失效了
- 写入缓存的效率要远比更新数据库的效率要高, 查完数据库到写入完缓存的时间非常短,不容易有线程插进来

两种情况都有导致缓存不一致的可能, 但是第二种的可能性非常低,因为：

1. 第二种不一致的前提是某种原因导致缓存已经失效,使读请求进来时未命中

2. 写入缓存的效率要远比更新数据库的效率要高, 第二种情况,在读线程查完数据库到写入完缓存的时间非常短,不容易有线程插进来.而第一种,由于更新数据库的时间相对较长, 更容易被其他线程抢占

#### 延迟双删

我们先删除缓存，然后更新数据库的值，更新完数据库值以后，我们可以让**线程先 sleep 一小段时间，再进行一次缓存删除操作**。

有了sleep 的这段时间，即使有其他缓存从数据库读取到旧的值并重新放到缓存中，我们也能再次删除，保证缓存中会是新的值。至于sleep的这个时间如何确定？以实际业务执行时间为准。


