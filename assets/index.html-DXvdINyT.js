import{_ as a,c as e,a as n,o as i}from"./app-CbO9e9FJ.js";const p={};function l(d,s){return i(),e("div",null,s[0]||(s[0]=[n(`<h2 id="rdb" tabindex="-1"><a class="header-anchor" href="#rdb"><span>RDB</span></a></h2><p>RDB 是 redis 的数据备份文件，也叫数据快照，就是把 redis 中的所有数据都记录在磁盘中。当 redis 出现故障重启后，从磁盘中读取这个文件恢复数据。 快照文件又叫 RDB 文件，默认存在运行目录。</p><div class="language-bash line-numbers-mode" data-ext="bash" data-title="bash"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 持久化命令 需要等待返回ok 适合在需要主动停止redis的时候或者redis马上就要宕机的时候使用</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">save</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> # redis主进程来执行RDB，会阻塞所有命令，因为redis是单进程单线程的</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 推荐使用</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">bgsave</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  # 开启子线程在后台执行保存</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Redis默认是开启RDB的</p><p>配置文件配置调整:</p><div class="language-conf line-numbers-mode" data-ext="conf" data-title="conf"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>#  60 秒内有 1000 个 key 出现修改我就执行 RDB</span></span>
<span class="line"><span>save 60 1000</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#关闭rdb 不自动执行rdb</span></span>
<span class="line"><span>save &quot;&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="bgsave命令" tabindex="-1"><a class="header-anchor" href="#bgsave命令"><span>bgsave命令</span></a></h3><p>bgsave 命令是 fork 主进程得到子进程，子进程共享主进程的内存数据，完成 fork 后读取内存数据并写入 RDB 文件中</p><ul><li>fork 的过程是阻塞的，redis 主进程无法做其他事情，完成后就随便做什么操作了</li></ul><p>fork 采用的是 copy-on-write 技术：</p><ul><li>当主进程执行读操作时，访问共享内存；</li><li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</li><li>fork 完成后子进程和主进程共享一个内存，这个内存会变成只读，可以保证这次数据不会发生变化，如果子进程在写入 RDB 的时候，主进程需要修改数据，那么他就会拷贝一份需要修改的内容在内存中，不会影响到共享内存</li></ul><p><img src="https://image.oyyp.top/img/202412211521874.png" alt="image.png"></p><p>💡 页表是虚拟内存和物理内存的一个映射关系，每个进程都有自己的虚拟内存，进程无法直接操作物理内存，但是有映射关系，修改这个虚拟内存的数据的时候，根据映射关系也就间接的修改了物理内存</p><h3 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点"><span>缺点</span></a></h3><ol><li>RDB 执行间隔长，两次 RDB 之间会存在数据丢失的风险 <code>通过配置文件设置 save 60 1000 可以控制 RDB 执行，这个命令等价于 60 秒内有 1000 个 key 出现修改我就执行 RDB，这个 60 和 1000 不好设置，太长会导致数据丢失，太短会造成 CPU 压力</code></li><li>fork 子进程、压缩、写出 RDB 文件都比较耗时</li></ol><h2 id="aof" tabindex="-1"><a class="header-anchor" href="#aof"><span>AOF</span></a></h2><p>AOF也叫追加文件。Redis处理的每个命令都会保存在AOF文件中，所以AOF其实是一个redis命令日志文件</p><p>AOF默认关闭，需要修改配置文件</p><div class="language-conf line-numbers-mode" data-ext="conf" data-title="conf"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span># 是否开启AOF</span></span>
<span class="line"><span>appendonly yes</span></span>
<span class="line"><span></span></span>
<span class="line"><span># AOF文件名称</span></span>
<span class="line"><span>appendfilename &quot;文件名称.aof&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>AOF执行策略 配置文件声明 appendfsync appendfsync 可以配置如下3个：</p><div class="language-conf line-numbers-mode" data-ext="conf" data-title="conf"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>#表示每执行一次写命令，立即记录到AOF文件 能保证数据安全性最高，性能最差</span></span>
<span class="line"><span># 这里执行其实是两步，主进程写入内存，然后在保存在AOF文件中才返回成功 要写入内存又要写入磁盘所以性能不好</span></span>
<span class="line"><span>appendfsync always</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#写命令执行完先放入AOF缓冲区（内存），然后每隔1秒将缓冲区数据写到AOF文件，是默认方案</span></span>
<span class="line"><span># 有1s间隔，在这1s的时候出现宕机，导致数据会丢失，丢失的数据也就是1s内的数据</span></span>
<span class="line"><span>appendfsync everysec</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span></span>
<span class="line"><span>appendfsync no</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="缺点-1" tabindex="-1"><a class="header-anchor" href="#缺点-1"><span>缺点</span></a></h3><p>每次执行写命令都会写入aof文件中导致aof文件特别大，而且写入同一个key的时候，只有最后一个写入命令才有效，之前aof记录的无效，那么怎么优化呢？</p><div class="language-bash line-numbers-mode" data-ext="bash" data-title="bash"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 通过这个命令重写aof文件</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">bgrewriteaof</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>可以通过配置文件配置bgrewriteaof命令执行契机：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>#AOF文件比上次文件增长超过多少百分比则触发重写</span></span>
<span class="line"><span>auto-aof-rewrite-percentage 100</span></span>
<span class="line"><span>#AOF文件体积最小多大以上才触发重写</span></span>
<span class="line"><span>auto-aof-rewrite-min-size 64mb</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="rdb-和-aof比较" tabindex="-1"><a class="header-anchor" href="#rdb-和-aof比较"><span>RDB 和 AOF比较</span></a></h2><p>RDB存的是数据，AOF存的是命令</p><p><img src="https://image.oyyp.top/img/202412211609838.png" alt="image.png"></p><h2 id="rdb和aof结合使用" tabindex="-1"><a class="header-anchor" href="#rdb和aof结合使用"><span>RDB和AOF结合使用</span></a></h2><p>同时开启rdb和aof持久化时，重启只会加载aof文件，不会加载rdb文件，aof优先级高于rdb</p><p><strong>开启两种持久化：</strong></p><p>（1）在这种情况下，当redis重启的时候会优先载入aof文件来恢复原始的数据，</p><p>因为在通常情况下aof文件保存的数据集要比rdb文件保存的数据集要完整（一秒一次）</p><p>（2）rdb数据不是实时的，同时使用两者时服务器重启也只会找aof文件，那要不要只使用aof呢？</p><p>作者建议不要，因为rdb更适合用于备份数据库（aof在不断变化不好备份），留着rdb作为一个万一的手段</p><p><strong>方式：</strong></p><p>（1）开启混合模式</p><p>aof-use-rdb-preamble no 是否开启混合方式</p><p>（2）aof+rdb混合方式</p><p>二者搭配流程：RDB做全量持久化，AOF做增量持久化，意思就是RDB先通过快照的方式，先将系统或数据集里面的全部内容保存下来，然后，过后的一段时间（没有触发RDB的fsync）,就属于变化的数据（写命令），这些写命令就存到aof文件里面，二者同时发挥作用。</p><p><strong>同时关闭rdb+aof</strong></p><p>（1）save &quot;&quot;：禁用rdb，在禁用模式下，仍然可以使用命令save，bgsave生成rdb文件</p><p>（2）appendonly no:禁用aof，也可以使用命令生成aof文件</p>`,44)]))}const r=a(p,[["render",l],["__file","index.html.vue"]]),c=JSON.parse('{"path":"/%E6%8A%80%E6%9C%AF%E6%A0%88/d21yminx/","title":"Redis持久化","lang":"zh-CN","frontmatter":{"title":"Redis持久化","createTime":"2025/04/01 14:23:52","permalink":"/技术栈/d21yminx/"},"headers":[],"readingTime":{"minutes":4.82,"words":1446},"git":{"updatedTime":1735383939000,"contributors":[{"name":"oyyp","email":"513150165@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/oyyp?v=4","url":"https://github.com/oyyp"}]},"filePathRelative":"notes/技术栈/Redis/Redis持久化.md","categoryList":[{"id":"4358b5","sort":10000,"name":"notes"},{"id":"659f61","sort":10003,"name":"技术栈"},{"id":"5e6003","sort":10007,"name":"Redis"}],"bulletin":false}');export{r as comp,c as data};
