import{_ as t,c as a,a as i,o as s}from"./app-CbO9e9FJ.js";const r={};function n(o,e){return s(),a("div",null,e[0]||(e[0]=[i('<p>Redis 所有的数据结构都可以设置过期时间，时间一到，就会自动删除。但是会不会因为同一时间太多的 key 过 期，以至于忙不过来。同时因为 Redis 是单线程的，删除的时间也会占用线程的处理时间，如果删除的太过于繁 忙，会不会导致线上读写指令出现卡顿。</p><p>redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，以后会定时遍历这个字典来删除到期的 key。除了定时遍历之外，它还会使用惰性策略来删除过期的 key，所谓情性策略就是在客户端访问这个 key 的时候，redis 对 key 的过期时间进行检 查，如果过期了就立即删除。定时删除是集中处理，惰性删除是零散处理。</p><h2 id="定期删除" tabindex="-1"><a class="header-anchor" href="#定期删除"><span>定期删除</span></a></h2><p>Redis 默认会每秒进行十次过期扫描，执行周期100ms，过期扫描不会遍历过期字典中所有的 key，而是采用了一种简单的贪心策 略。</p><ol><li>过期字典中随机 20 个 key;</li><li>删除这 20 个 key 中已经过期的 key;</li><li>如果过期的 key 比率超过 1/4，那就重复步骤 1;</li></ol><p>通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得 CPU 和内存资源达到最优的平衡效果</p><p>redis集群中，定时删除的并不会立马同步到从机中，会放到一个日志中，等待从机去执行</p><h2 id="惰性删除" tabindex="-1"><a class="header-anchor" href="#惰性删除"><span>惰性删除</span></a></h2><ul><li>当客户端尝试访问某个键时，Redis 会先检查该键是否设置了过期时间，并判断是否过期。</li><li>如果键已过期，则 Redis 会立即将其删除。这就是惰性删除策略。</li></ul><p>该策略可以最大化地节省<a href="https://so.csdn.net/so/search?q=CPU&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener noreferrer">CPU</a>资源，却对内存非常不友好。极端情况可能出现大量的过期 key 没有再次被访问，从而不会被清除，占用大量内存。</p>',10)]))}const d=t(r,[["render",n],["__file","index.html.vue"]]),p=JSON.parse('{"path":"/%E6%8A%80%E6%9C%AF%E6%A0%88/8nh8cm41/","title":"Redis过期策略","lang":"zh-CN","frontmatter":{"title":"Redis过期策略","createTime":"2025/04/01 14:23:52","permalink":"/技术栈/8nh8cm41/"},"headers":[],"readingTime":{"minutes":1.84,"words":553},"git":{"updatedTime":1733307530000,"contributors":[{"name":"oyyp","email":"513150165@qq.com","commits":2,"avatar":"https://avatars.githubusercontent.com/oyyp?v=4","url":"https://github.com/oyyp"}]},"filePathRelative":"notes/技术栈/Redis/Redis过期策略.md","categoryList":[{"id":"4358b5","sort":10000,"name":"notes"},{"id":"659f61","sort":10003,"name":"技术栈"},{"id":"5e6003","sort":10007,"name":"Redis"}],"bulletin":false}');export{d as comp,p as data};
