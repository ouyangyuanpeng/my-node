import{_ as e,c as l,a as n,o as i}from"./app-DVUdVNdS.js";const a={};function r(d,t){return i(),l("div",null,t[0]||(t[0]=[n('<h2 id="innodb-记录结构" tabindex="-1"><a class="header-anchor" href="#innodb-记录结构"><span>InnoDB 记录结构</span></a></h2><h3 id="compact-行格式" tabindex="-1"><a class="header-anchor" href="#compact-行格式"><span>COMPACT 行格式</span></a></h3><p>​<img src="https://image.oyyp.top/img/202409211657401.png" alt="4-1.png">​</p><h4 id="记录的额外信息" tabindex="-1"><a class="header-anchor" href="#记录的额外信息"><span>记录的额外信息</span></a></h4><p>这部分信息是服务器为了描述这条记录而不得不额外添加的一些信息，这些额外信息分为 3 类，分别是变长字段长度列表 ​、NULL 值列表 ​ 和记录头信息 ​，我们分别看一下。</p><h5 id="变长字段长度列表" tabindex="-1"><a class="header-anchor" href="#变长字段长度列表"><span>变长字段长度列表</span></a></h5><ul><li>如 VARCHAR(M)​、VARBINARY(M)​、各种 TEXT​ 类型，各种 BLOB​ 类型，我们也可以把拥有这些数据类型的列称为变长字段 ​</li><li>在 Compact​ 行格式中，把所有变长字段的真实数据占用的字节长度 ​ 都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序逆序存放，我们再次强调一遍，是逆序存放！</li><li>使用 1-2 个字节存储变长字段实际所占字节长度存储在变成字段长度列表中</li><li>对于一些占用字节数非常多的字段，比方说某个字段长度大于了 16KB，那么如果该记录在单个页面中无法存储时，InnoDB 会把一部分数据存放到所谓的溢出页中（我们后边会介绍），在变长字段长度列表处只存储留在本页面中的长度，所以使用两个字节也可以存放下来。</li></ul><p>💡CHAR 类型根据字符集的不同也会存在变长字段列表中，utf-8 字符集占用的字节数为 1-3 所以使用 utf-8 的字符集的 char 也会存在变长字段长度列表中。</p><h5 id="null-值列表" tabindex="-1"><a class="header-anchor" href="#null-值列表"><span>NULL 值列表</span></a></h5><p>我们知道表中的某些列可能存储 NULL​ 值，如果把这些 NULL​ 值都放到记录的真实数据 ​ 中存储会很占地方，所以 Compact​ 行格式把这些值为 NULL​ 的列统一管理起来，存储到 NULL​ 值列表中</p><ol><li><p>首先统计表中允许存储 NULL​ 的列有哪些。<br> 我们前面说过，主键列、被 NOT NULL​ 修饰的列都是不可以存储 NULL​ 值的，所以在统计的时候不会把这些列算进去。比方说表 record_format_demo​ 的 3 个列 c1​、c3​、c4​ 都是允许存储 NULL​ 值的，而 c2​ 列是被 NOT NULL​ 修饰，不允许存储 NULL​ 值。</p></li><li><p>如果表中没有允许存储 NULL 的列，则 NULL 值列表 也不存在了，否则将每个允许存储 NULL​ 的列对应一个二进制位，二进制位按照列的顺序逆序排列，二进制位表示的意义如下：</p><ul><li>二进制位的值为 1​ 时，代表该列的值为 NULL​。</li><li>二进制位的值为 0​ 时，代表该列的值不为 NULL​。</li></ul></li></ol><h5 id="记录头信息" tabindex="-1"><a class="header-anchor" href="#记录头信息"><span>记录头信息</span></a></h5><p>查看参考文档</p><h2 id="innodb-数据页" tabindex="-1"><a class="header-anchor" href="#innodb-数据页"><span>InnoDB 数据页</span></a></h2><ol><li><p>页与页之间是一个双向链表，位置信息存放在 File Header​ 中</p></li><li><p>页中的数据都按照注主键大小进行排序，小-&gt;大</p></li></ol><h3 id="innodb-数据页结构" tabindex="-1"><a class="header-anchor" href="#innodb-数据页结构"><span>InnoDB 数据页结构</span></a></h3><p>​<img src="https://image.oyyp.top/img/20241022221956.png" alt="">​</p><table><thead><tr><th style="text-align:center;">名称</th><th style="text-align:center;">中文名</th><th style="text-align:center;">占用空间大小</th><th style="text-align:center;">简单描述</th></tr></thead><tbody><tr><td style="text-align:center;">​File Header​</td><td style="text-align:center;">文件头部</td><td style="text-align:center;">​38​ 字节</td><td style="text-align:center;">页的一些通用信息</td></tr><tr><td style="text-align:center;">​Page Header​</td><td style="text-align:center;">页面头部</td><td style="text-align:center;">​56​ 字节</td><td style="text-align:center;">数据页专有的一些信息</td></tr><tr><td style="text-align:center;">​Infimum + Supremum​</td><td style="text-align:center;">最小记录和最大记录</td><td style="text-align:center;">​26​ 字节</td><td style="text-align:center;">两个虚拟的行记录</td></tr><tr><td style="text-align:center;">​User Records​</td><td style="text-align:center;">用户记录</td><td style="text-align:center;">不确定</td><td style="text-align:center;">实际存储的行记录内容</td></tr><tr><td style="text-align:center;">​Free Space​</td><td style="text-align:center;">空闲空间</td><td style="text-align:center;">不确定</td><td style="text-align:center;">页中尚未使用的空间</td></tr><tr><td style="text-align:center;">​Page Directory​</td><td style="text-align:center;">页面目录</td><td style="text-align:center;">不确定</td><td style="text-align:center;">页中的某些记录的相对位置</td></tr><tr><td style="text-align:center;">​File Trailer​</td><td style="text-align:center;">文件尾部</td><td style="text-align:center;">​8​ 字节</td><td style="text-align:center;">校验页是否完整</td></tr></tbody></table><h3 id="行记录头信息" tabindex="-1"><a class="header-anchor" href="#行记录头信息"><span>行记录头信息</span></a></h3><p>​<img src="https://image.oyyp.top/img/20241022222748.png" alt="">​</p><table><thead><tr><th style="text-align:center;">名称</th><th style="text-align:center;">大小（单位：bit）</th><th style="text-align:center;">描述</th></tr></thead><tbody><tr><td style="text-align:center;">​ 预留位 1​</td><td style="text-align:center;">​1​</td><td style="text-align:center;">没有使用</td></tr><tr><td style="text-align:center;">​ 预留位 2​</td><td style="text-align:center;">​1​</td><td style="text-align:center;">没有使用</td></tr><tr><td style="text-align:center;">​delete_mask​</td><td style="text-align:center;">​1​</td><td style="text-align:center;">标记该记录是否被删除</td></tr><tr><td style="text-align:center;">​min_rec_mask​</td><td style="text-align:center;">​1​</td><td style="text-align:center;">B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td style="text-align:center;">​n_owned​</td><td style="text-align:center;">​4​</td><td style="text-align:center;">表示当前记录拥有的记录数</td></tr><tr><td style="text-align:center;">​heap_no​</td><td style="text-align:center;">​13​</td><td style="text-align:center;">表示当前记录在记录堆的位置信息</td></tr><tr><td style="text-align:center;">​record_type​</td><td style="text-align:center;">​3​</td><td style="text-align:center;">表示当前记录的类型，0​ 表示普通记录，1​ 表示 B+树非叶节点记录，2​ 表示最小记录，3​ 表示最大记录</td></tr><tr><td style="text-align:center;">​next_record​</td><td style="text-align:center;">​16​</td><td style="text-align:center;">表示下一条记录的相对位置</td></tr></tbody></table><ul><li>delete_mask ​0​ 没有删除 1​ 表示删除，被删除的记录并不会立马释放占用的空间，只是被标记为 1​，它还在真实的磁盘上，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，被删除的记录他们会组成一个链表 ​，他们占用的空间视为可重用空间 ​，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉</li><li>record_type 这个属性表示当前记录的类型，一共有 4 种类型的记录，0​ 表示普通记录，1​ 表示 B+树非叶节点记录，2​ 表示最小记录，3​ 表示最大记录。从图中我们也可以看出来，我们自己插入的记录就是普通记录，它们的 record_type​ 值都是 0​，而最小记录和最大记录的 record_type​ 值分别为 2​ 和 3​。</li><li>next_record 这玩意儿非常重要，它表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。比方说第一条记录的 next_record​ 值为 32​，意味着从第一条记录的真实数据的地址处向后找 32​ 个字节便是下一条记录的真实数据。如果你熟悉数据结构的话，就立即明白了，这其实是个链表 ​，可以通过一条记录找到它的下一条记录。但是需要注意注意再注意的一点是下一条记录 ​ 指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定 Infimum 记录（也就是最小记录） 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 Supremum 记录（也就是最大记录），指向的地址不是记录的头部，而是记录头和真实数据的中间</li><li>​n_owned​ 组内最大的那条记录 n_owned​ 的值=该组内共有几条记录</li></ul><h3 id="page-directory-页目录" tabindex="-1"><a class="header-anchor" href="#page-directory-页目录"><span>Page Directory（页目录）</span></a></h3><p>现在我们了解了记录在页中按照主键值由小到大顺序串联成一个单链表，那如果我们想根据主键值查找页中的某条记录该咋办呢？比如说这样的查询语句：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">SELECT</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> FROM</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> page_demo </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">WHERE</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> c1 </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 3</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">Copy</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> to</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> clipboardErrorCopied</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>最笨的办法：从 Infimum​ 记录（最小记录）开始，沿着链表一直往后找，总有一天会找到（或者找不到[摊手]），在找的时候还能投机取巧，因为链表中各个记录的值是按照从小到大顺序排列的，所以当链表的某个节点代表的记录的主键值大于你想要查找的主键值时，你就可以停止查找了，因为该节点后边的节点的主键值依次递增。</p><p>这个方法在页中存储的记录数量比较少的情况用起来也没什么问题，比方说现在我们的表里只有 4​ 条自己插入的记录，所以最多找 4​ 次就可以把所有记录都遍历一遍，但是如果一个页中存储了非常多的记录，这么查找对性能来说还是有损耗的，所以我们说这种遍历查找这是一个笨 ​ 办法。但是设计 InnoDB​ 的大佬们是什么人，他们能用这么笨的办法么，当然是要设计一种更 6 的查找方式喽，他们从书的目录中找到了灵感。</p><p>我们平常想从一本书中查找某个内容的时候，一般会先看目录，找到需要查找的内容对应的书的页码，然后到对应的页码查看内容。设计 InnoDB​ 的大佬们为我们的记录也制作了一个类似的目录，他们的制作过程是这样的：</p><ol><li>将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。</li><li>每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的 n_owned​ 属性表示该记录拥有多少条记录，也就是该组内共有几条记录。</li><li>将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近页 ​ 的尾部的地方，这个地方就是所谓的 Page Directory​，也就是页目录 ​（此时应该返回头看看页面各个部分的图）。页面目录中的这些地址偏移量被称为槽 ​（英文名：Slot​），所以这个页面目录就是由槽 ​ 组成的。</li></ol><p>比方说现在的 page_demo​ 表中正常的记录共有 6 条，InnoDB​ 会把它们分成两组，第一组中只有一个最小记录，第二组中是剩余的 5 条记录，看下面的示意图：</p><p>​<img src="https://image.oyyp.top/img/20241022224908.png" alt="">​</p><h4 id="在页中查找记录的方式" tabindex="-1"><a class="header-anchor" href="#在页中查找记录的方式"><span>在页中查找记录的方式</span></a></h4><p>现在看怎么从这个页目录 ​ 中查找记录。因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用所谓的二分法 ​ 来进行快速查找。4 个槽的编号分别是：0​、1​、2​、3​、4​，所以初始情况下最低的槽就是 low=0​，最高的槽就是 high=4​。比方说我们想找主键值为 6​ 的记录，过程是这样的：</p><ol><li>计算中间槽的位置：(0+4)/2=2​，所以查看槽 2​ 对应记录的主键值为 8​，又因为 8 &gt; 6​，所以设置 high=2​，low​ 保持不变。</li><li>重新计算中间槽的位置：(0+2)/2=1​，所以查看槽 1​ 对应的主键值为 4​，又因为 4 &lt; 6​，所以设置 low=1​，high​ 保持不变。</li><li>因为 high - low​ 的值为 1，所以确定主键值为 6​ 的记录在槽 2​ 对应的组中。此刻我们需要找到槽 2​ 中主键值最小的那条记录，然后沿着单向链表遍历槽 2​ 中的记录。但是我们前面又说过，每个槽对应的记录都是该组中主键值最大的记录，这里槽 2​ 对应的记录是主键值为 8​ 的记录，怎么定位一个组中最小的记录呢？别忘了各个槽都是挨着的，我们可以很轻易的拿到槽 1​ 对应的记录（主键值为 4​），该条记录的下一条记录就是槽 2​ 中主键值最小的记录，该记录的主键值为 5​。所以我们可以从这条主键值为 5​ 的记录出发，遍历槽 2​ 中的各条记录，直到找到主键值为 6​ 的那条记录即可。由于一个组中包含的记录条数只能是 1~8 条，所以遍历一个组中的记录的代价是很小的。</li></ol><p>所以在一个数据页中查找指定主键值的记录的过程分为两步：</p><ol><li>通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录。</li><li>通过记录的 next_record​ 属性遍历该槽所在的组中的各个记录。</li></ol><h3 id="page-header-页面头部" tabindex="-1"><a class="header-anchor" href="#page-header-页面头部"><span>Page Header（页面头部）</span></a></h3><p>设计 InnoDB​ 的大佬们为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫 Page Header​ 的部分，它是页 ​ 结构的第二部分，这个部分占用固定的 56​ 个字节，专门存储各种状态信息，具体各个字节都是干嘛的看下表：</p><table><thead><tr><th style="text-align:center;">名称</th><th style="text-align:center;">占用空间大小</th><th style="text-align:center;">描述</th></tr></thead><tbody><tr><td style="text-align:center;">​PAGE_N_DIR_SLOTS​</td><td style="text-align:center;">​2​ 字节</td><td style="text-align:center;">在页目录中的槽数量</td></tr><tr><td style="text-align:center;">​PAGE_HEAP_TOP​</td><td style="text-align:center;">​2​ 字节</td><td style="text-align:center;">还未使用的空间最小地址，也就是说从该地址之后就是 Free Space​</td></tr><tr><td style="text-align:center;">​PAGE_N_HEAP​</td><td style="text-align:center;">​2​ 字节</td><td style="text-align:center;">本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</td></tr><tr><td style="text-align:center;">​PAGE_FREE​</td><td style="text-align:center;">​2​ 字节</td><td style="text-align:center;">第一个已经标记为删除的记录地址（各个已删除的记录通过 next_record​ 也会组成一个单链表，这个单链表中的记录可以被重新利用）</td></tr><tr><td style="text-align:center;">​PAGE_GARBAGE​</td><td style="text-align:center;">​2​ 字节</td><td style="text-align:center;">已删除记录占用的字节数</td></tr><tr><td style="text-align:center;">​PAGE_LAST_INSERT​</td><td style="text-align:center;">​2​ 字节</td><td style="text-align:center;">最后插入记录的位置</td></tr><tr><td style="text-align:center;">​PAGE_DIRECTION​</td><td style="text-align:center;">​2​ 字节</td><td style="text-align:center;">记录插入的方向</td></tr><tr><td style="text-align:center;">​PAGE_N_DIRECTION​</td><td style="text-align:center;">​2​ 字节</td><td style="text-align:center;">一个方向连续插入的记录数量</td></tr><tr><td style="text-align:center;">​PAGE_N_RECS​</td><td style="text-align:center;">​2​ 字节</td><td style="text-align:center;">该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</td></tr><tr><td style="text-align:center;">​PAGE_MAX_TRX_ID​</td><td style="text-align:center;">​8​ 字节</td><td style="text-align:center;">修改当前页的最大事务 ID，该值仅在二级索引中定义</td></tr><tr><td style="text-align:center;">​PAGE_LEVEL​</td><td style="text-align:center;">​2​ 字节</td><td style="text-align:center;">当前页在 B+树中所处的层级</td></tr><tr><td style="text-align:center;">​PAGE_INDEX_ID​</td><td style="text-align:center;">​8​ 字节</td><td style="text-align:center;">索引 ID，表示当前页属于哪个索引</td></tr><tr><td style="text-align:center;">​PAGE_BTR_SEG_LEAF​</td><td style="text-align:center;">​10​ 字节</td><td style="text-align:center;">B+树叶子段的头部信息，仅在 B+树的 Root 页定义</td></tr><tr><td style="text-align:center;">​PAGE_BTR_SEG_TOP​</td><td style="text-align:center;">​10​ 字节</td><td style="text-align:center;">B+树非叶子段的头部信息，仅在 B+树的 Root 页定义</td></tr></tbody></table><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><ol><li><p>InnoDB 为了不同的目的而设计了不同类型的页，我们把用于存放记录的页叫做数据页 ​。</p></li><li><p>一个数据页可以被大致划分为 7 个部分，分别是</p><ul><li>​File Header​，表示页的一些通用信息，占固定的 38 字节。</li><li>​Page Header​，表示数据页专有的一些信息，占固定的 56 个字节。</li><li>​Infimum + Supremum​，两个虚拟的伪记录，分别表示页中的最小和最大记录，占固定的 26​ 个字节。</li><li>​User Records​：真实存储我们插入的记录的部分，大小不固定。</li><li>​Free Space​：页中尚未使用的部分，大小不确定。</li><li>​Page Directory​：页中的某些记录相对位置，也就是各个槽在页面中的地址偏移量，大小不固定，插入的记录越多，这个部分占用的空间越多。</li><li>​File Trailer​：用于检验页是否完整的部分，占用固定的 8 个字节。</li></ul></li><li><p>每个记录的头信息中都有一个 next_record​ 属性，从而使页中的所有记录串联成一个单链表 ​。</p></li><li><p>​InnoDB​ 会为把页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个槽 ​，存放在 Page Directory​ 中，所以在一个页中根据主键查找记录是非常快的，分为两步：</p><ul><li>通过二分法确定该记录所在的槽。</li><li>通过记录的 next_record 属性遍历该槽所在的组中的各个记录。</li></ul></li><li><p>每个数据页的 File Header​ 部分都有上一个和下一个页的编号，所以所有的数据页会组成一个双链表 ​。</p></li><li><p>为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的校验和和页面最后修改时对应的 LSN​ 值，如果首部和尾部的校验和和 LSN​ 值校验不成功的话，就说明同步过程出现了问题。</p></li></ol>',41)]))}const c=e(a,[["render",r],["__file","index.html.vue"]]),p=JSON.parse('{"path":"/%E6%95%B0%E6%8D%AE%E5%BA%93/iwmj8xcr/","title":"Mysql学习","lang":"zh-CN","frontmatter":{"title":"Mysql学习","createTime":"2024/11/14 10:21:26","permalink":"/数据库/iwmj8xcr/"},"headers":[],"readingTime":{"minutes":13.06,"words":3918},"git":{"updatedTime":1732074236000,"contributors":[{"name":"oyyp","email":"513150165@qq.com","commits":3,"avatar":"https://avatars.githubusercontent.com/oyyp?v=4","url":"https://github.com/oyyp"}]},"filePathRelative":"notes/数据库/Mysql/InnoDB.md","categoryList":[{"id":"4358b5","sort":10000,"name":"notes"},{"id":"324a5c","sort":10003,"name":"数据库"},{"id":"3aab05","sort":10004,"name":"Mysql"}],"bulletin":false}');export{c as comp,p as data};
