import{_ as e,c as i,a as l,o as p}from"./app-CbO9e9FJ.js";const s={};function n(t,a){return p(),i("div",null,a[0]||(a[0]=[l('<h2 id="操作缓存和数据库是有3个问题需要考虑" tabindex="-1"><a class="header-anchor" href="#操作缓存和数据库是有3个问题需要考虑"><span>操作缓存和数据库是有3个问题需要考虑</span></a></h2><h3 id="删除缓存还是更新缓存" tabindex="-1"><a class="header-anchor" href="#删除缓存还是更新缓存"><span>删除缓存还是更新缓存</span></a></h3><h4 id="更新缓存" tabindex="-1"><a class="header-anchor" href="#更新缓存"><span>更新缓存</span></a></h4><ol><li><p>每次更新数据库都更新缓存，无效写操作多，每次都去更新缓存会耗时而且会增加redis压力</p></li><li><p>如果这个时候去更新数据，需要去遍历找到对应的值在去修改比较耗时。</p></li></ol><h4 id="删除缓存-推荐" tabindex="-1"><a class="header-anchor" href="#删除缓存-推荐"><span>删除缓存（推荐）</span></a></h4><ol><li><p>每次更新数据库时删除缓存，查询的时候在添加到缓存中</p></li><li><p>使用的时候才更新缓存。使用的时候才从DB中加载，也可以采用异步的方式填充缓存，比如开启一个线程定时将DB的数据刷到缓存中。</p></li></ol><h3 id="如何保证缓存与数据库的操作同时失败和成功" tabindex="-1"><a class="header-anchor" href="#如何保证缓存与数据库的操作同时失败和成功"><span>如何保证缓存与数据库的操作同时失败和成功</span></a></h3><ol><li>单体系统，把缓存和数据库放在一个事务中</li><li>分布式系统，使用TCC分布式事务</li></ol><h3 id="先操作缓存还是先操作数据库" tabindex="-1"><a class="header-anchor" href="#先操作缓存还是先操作数据库"><span>先操作缓存还是先操作数据库</span></a></h3><p>高并发情况下存在线程交叉执行，导致数据库缓存不一致情况</p><p>建议先更新数据库后删除缓存，因为这种情况出现问题概率较小，但是一样无法保证一定不出问题，只是这样出现问题的概率较小</p><h4 id="先更新数据库-再更新缓存" tabindex="-1"><a class="header-anchor" href="#先更新数据库-再更新缓存"><span>先更新数据库，再更新缓存</span></a></h4><p>如果同时有两个写请求需要更新数据，每个写请求都先更新数据库再更新缓存，在并发场景可能会出现数据不一致的情况。</p><p><img src="https://image.oyyp.top/img/202411281635027.png" alt="image.png"></p><ol><li>写请求1更新数据库，将 age 字段更新为18；</li><li>写请求2更新数据库，将 age 字段更新为20；</li><li>写请求2更新缓存，缓存 age 设置为20；</li><li>写请求1更新缓存，缓存 age 设置为18；</li></ol><p>​ 执行完预期结果是数据库 age 为20，缓存 age 为20，结果缓存 age为18，这就造成了缓存数据不是最新的，出现了<a href="https://so.csdn.net/so/search?q=%E8%84%8F%E6%95%B0%E6%8D%AE&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener noreferrer">脏数据</a>。</p><h4 id="先删缓存-再更新数据库" tabindex="-1"><a class="header-anchor" href="#先删缓存-再更新数据库"><span>先删缓存，再更新数据库</span></a></h4><p><img src="https://image.oyyp.top/img/202411281637962.png" alt="image.png"></p><ol><li>写请求删除缓存数据；</li><li>读请求查询缓存未击中，紧接着查询数据库，将返回的数据回写到缓存中；</li><li>写请求更新数据库。</li></ol><p>结果：缓存是18 数据库是20</p><ul><li>读请求已经设置了缓存，导致之后的读请求会一直获取到缓存中的值，但是这个值是错误的，只能等待下一个写请求才能重新修改缓存的值，导致大多数读请求都读取到错误的值</li><li>先删除缓存，在更新数据库导致图片中的情况出现概率较高</li><li>由于更新数据库的时间相对较长, 更容易被其他线程抢占</li></ul><h4 id="先更新数据库-再删除缓存-推荐" tabindex="-1"><a class="header-anchor" href="#先更新数据库-再删除缓存-推荐"><span>先更新数据库，再删除缓存（推荐）</span></a></h4><p>在实际的系统中针对写请求还是推荐先更新数据库再删除缓存，但是在理论上还是存在问题。</p><p><img src="https://image.oyyp.top/img/202411281638631.png" alt="image.png"></p><ol><li>读请求先查询缓存，缓存未击中（key过期），查询数据库返回数据；</li><li>写请求更新数据库，删除缓存；</li><li>读请求回写缓存；</li></ol><ul><li>极端情况下需要满足的条件稍微苛刻一点，需要保证刚好key失效了</li><li>写入缓存的效率要远比更新数据库的效率要高, 查完数据库到写入完缓存的时间非常短,不容易有线程插进来</li></ul><p>两种情况都有导致缓存不一致的可能, 但是第二种的可能性非常低,因为：</p><ol><li><p>第二种不一致的前提是某种原因导致缓存已经失效,使读请求进来时未命中</p></li><li><p>写入缓存的效率要远比更新数据库的效率要高, 第二种情况,在读线程查完数据库到写入完缓存的时间非常短,不容易有线程插进来.而第一种,由于更新数据库的时间相对较长, 更容易被其他线程抢占</p></li></ol><h4 id="延迟双删" tabindex="-1"><a class="header-anchor" href="#延迟双删"><span>延迟双删</span></a></h4><p>我们先删除缓存，然后更新数据库的值，更新完数据库值以后，我们可以让<strong>线程先 sleep 一小段时间，再进行一次缓存删除操作</strong>。</p><p>有了sleep 的这段时间，即使有其他缓存从数据库读取到旧的值并重新放到缓存中，我们也能再次删除，保证缓存中会是新的值。至于sleep的这个时间如何确定？以实际业务执行时间为准。</p>',31)]))}const o=e(s,[["render",n],["__file","index.html.vue"]]),h=JSON.parse('{"path":"/%E6%8A%80%E6%9C%AF%E6%A0%88/rjooc0yz/","title":"Redis和数据库一致性问题","lang":"zh-CN","frontmatter":{"title":"Redis和数据库一致性问题","createTime":"2025/04/01 14:23:52","permalink":"/技术栈/rjooc0yz/"},"headers":[],"readingTime":{"minutes":3.99,"words":1198},"git":{"updatedTime":1733307530000,"contributors":[{"name":"oyyp","email":"513150165@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/oyyp?v=4","url":"https://github.com/oyyp"}]},"filePathRelative":"notes/技术栈/Redis/Redis和数据库一致性问题.md","categoryList":[{"id":"4358b5","sort":10000,"name":"notes"},{"id":"659f61","sort":10003,"name":"技术栈"},{"id":"5e6003","sort":10007,"name":"Redis"}],"bulletin":false}');export{o as comp,h as data};
